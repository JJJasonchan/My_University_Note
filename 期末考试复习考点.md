

## Python 基本

### `import ` 引入模块

`import` 语句可以引入一下模块类型:
1. Python 标准库
2. 库函数
3. 自定义的 `.py` 文件
4. 其他第三方库

### `__name__` 属性
这通常用于判断一个 `.py` 文件是被当作脚本直接运行，还是被当作模块导入。

#### 作业模块调用(`import`)

语法: `__name__ = 模块名`
解释:当你通过 `import my_script` 在另一个文件中导入这个脚本时，`__name__` 的值就是该文件的文件名（即 `my_script`）。

#### 直接运行

语法: `__name__ = "__main__`
解释:当你直接执行这个文件（例如在命令行输入 `python my_script.py`）时，系统会将 `__name__` 赋值为字符串 `"__main__"`。

经典的程序入口判断:

```Python
if __name__ == "__main__":
```

### big data 大数据

**大量数据**概括得到的有用信息
> Python 是最热门的处理大数据工具

### 数据类型

- Python 中<mark style="background: #ADCCFFA6;">处理的一切都是对象</mark>
- 对象分成两类:
  1. 内置
  2. 非内置(由 `import` 引入的)
- Python 中可对变量直接赋值,无需声明--先存储值在内存中,变量指向这个值

### 特殊规则

- Python 可以支持任意大的整数
- 复数中，虚部为 1
  在 Python 中表示复数必须带 `j`。重点是，如果虚部是 1，**必须写 `1j`**

### `zip` 函数和 `map` 函数

这两个函数都有**懒惰求值**的特性,他们不会在内存中生成完整列表,而是生成一个对象(地址),直到明确要求查看时才会计算.两者都必须用 `list()` 或 `tuple()` 才能“打开”它们看结果

#### `zip()` 拉链函数

`zip('abcd', [1, 2, 3])`
**功能描述**：它像拉链一样，将左右两边的数据按顺序“对齐”缝合。
- 第一对：`'a'` 和 `1` → `('a', 1)`
- 第二对：`'b'` 和 `2` → `('b', 2)`
- 第三对：`'c'` 和 `3` → `('c', 3)`
输出结果: `[('a', 1), ('b', 2), ('c', 3)]`
> zip 会以短的一边为准,两一边多出来的元素被舍弃

#### `map()`：映射函数

`map(str, range(5))`:它会将数据源里的每一个元素，依次通过前面的函数进行处理
- `str`：这是转换函数，指“转化为字符串”。
- `range(5)`：这是数据源，包含 `0, 1, 2, 3, 4` 这五个数字。


## 列表

### 列表的创建与删除

创建:
- 列举法:使用方括号 `[ ]`，内部元素用逗号 `,` 分开. e.g `x=[1,2,3]`
- 使用 `list` 函数:常用于把其他类型的数据（如元组、字符串）转换成列表。

删除:
- `del x`:把列表 x 从内存汇总删除

### 列表的使用

**列表访问 ** * **从左到右**：下标（Index）从 **0** 开始 * `x[0]` 代表第一个元素。

- **从右到左**：下标从 **-1** 开始。
    - `x[-1]` 代表最后一个元素（倒数第一个）。

**列表排序**

  - **`x.sort(key, reverse=True)`**：
    - 这是**永久性排序**，会直接改变 `x` 的顺序。
    - `reverse=True` 表示**降序**（从大到小），默认是升序。
  - `x.reverse()`:把列表**倒序**.

**列表切片操作**

- **语法**: `[start : end : step]`（起点 : 终点 : 步长）-->起点终点都是指的是*下标 index*

### 列表推导式

基本公式:            $[\underbrace{x * x}_{\text{表达式}} \quad \underbrace{\text{for } x \text{ in range}(10)}_{\text{变量取值范围}} \quad \underbrace{\text{if } x > 5}_{\text{变量满足条件}}]$
e.g

```Python
xyList = [x*x + y*y for x in range(10) if x > 5 for y in range(12) if y < 4]
```
解释:它相当于先通过 `x` 的循环（找大于 5 的数），再在内部跑 `y` 的循环（找小于 4 的数），最后计算 `x² + y²`。


## 元组
- 创建用 `()`
- `y=(3,)` --创建一个只有 `3` 的[[元组]]
- 访问速度比[[列表]]快
- 元祖成员访问:都是在元祖中取出一个值
  - 函数 `next(对象)`:可以设定默认值
  - 方法: `__next__()`:直接报错

e.g.
```python
nums = [1, 2, 3]#元组
num=next(nums) #从元组中取出一个数
```

## 集合

集合运算:
- 差集 `-` : `A-B` 是减去 A 中 B 的部分
- 对称集 `^` : `A^B`:是只在 A 中或只在 B 中,但不同时在 A 和 B 中的元素
e.g. 
```Python
A = {1, 2, 3, 4}
B = {3, 4, 5, 6}
A^B={1,2,5,6}
```


## 函数

### 匿名函数 `lamda` 表达式

`lamda` 表达式没有函数名,没有 `def`

定义: `f=lamda x,y,z : x+y+z`
> `x,y,z` 是变量, `x+y+z` 是输出表达式

调用: `f(1,2,3)`,**实参输入**

## 循环控制

Break 与 Continue 的区别:

- **`break` (中断)**：直接**跳出整个循环**，不再执行循环剩余的次数。循环彻底结束。
- **`continue` (继续)**：只**跳过当前这一次**循环的剩余语句，直接开始下一次循环


## 对象

类的定义: 
```Python
class name(父类):
	变量
	函数
	方法
```

- `self`:所有方法的第一个参数一般都是 `self`,核心作用是**代指当前类的实例对象本身**
	- `self` 实际代表**对象实例**
	- 在类内部,实例化过程传入的数据实际上是赋值给变量 self
- 对象调用方法: `<对象>.<方法>(参数)`
e.g.
```Python
gCar=GasCar("BYD")	#创建一个对象
gCar.run(200,0)#	#对象调用函数

#实际上执行的是GasCar.Run(gCar, 200.0)
```

### 特殊方法

- 构造函数 `__init__()`:初始化
- 析构函数 `__del__()` : 删除对象,收回对象空间

### 多继承

- Python 中一个类可以继承多个父类,多个父类含有相同的变量和方法
继承两个父类 `Vehicle` 和 `GasPower`
```Python
class GasCar(Vehicle, GasPower):	
```


## 字符串

- 一对单引号或双引号表示
- 一对三单引号或三双引号表示:
	- 可表示**多行字符串**
	- **三单引号的字符串若没有赋值给变量,就会看注释**

多行字符串实例:
```Python
multi_str = '''这是第一行
这是第二行
这是第三行'''
```

字符串的序号可正可负:
- 正递增序号从左到右,从 `0` 开始递增
- 反向递增序号从右到左,从 `-1` 开始递增
```
	-->012345
str="中国山东烟台"
	-6-5-4-3-2-1<--
```

使用 `[]` 可以获取一个字符或多个字符

```
str="中国山东烟台"
d[0]="中"
d[0:3]="中国山"
```

### 特殊字符

- `\` 转义符:转译成特殊字符原本的东西
- 在字符串之前加 `r` 或 `R` 表示原始字符串,一般用于转义字符表示原始的意思.

```Python
# 加r后，\n、\t都按字面显示
s2 = r"C:\new\test.txt"
#输出:C:\new\test.txt
```

特殊函数:
- `ord()` 接收一个**单个字符**，返回该字符对应的**Unicode 编码（整数）**
- `chr()`:接收一个**Unicode 编码（整数）**，返回该编码对应的**单个字符（长度为 1 的字符串）**

e.g.
```
ord('1')---> 49
chr(49)---> 1
```

### format 格式化

格式控制语法:

#### **精度与数字类型**:

| **场景**     | **代码示例**                | **结果**              | **说明**                     |
| ------------ | --------------------------- | --------------------- | ---------------------------- |
| **保留小数** | `f"{3.14159:.2f}"`          | `'3.14'`              | `.2f` 表示保留2位浮点数      |
| **百分比**   | `f"{0.85:.1%}"`             | `'85.0%'`             | 自动乘100并加%，`.1`为小数位 |
| **千分位**   | `f"{1000000:,}"`            | `'1,000,000'`         | 使用逗号作为分隔符           |
| **科学计数** | `f"{1000:.2e}"`             | `'1.00e+03'`          | 科学计数法                   |
| **进制转换** | `f"{255:x}"` / `f"{255:b}"` | `'ff'` / `'11111111'` | Hex(16进制) / Binary(2进制)  |

####  对齐与填充

语法：`:[填充字符][对齐方式][总宽度]`

```python
text = "Hi"

# 1. 右对齐，宽度10，默认空格填充
print(f"|{text:>10}|")  
# 输出: |        Hi|

# 2. 居中对齐，宽度10，使用 '=' 填充
print(f"|{text:=^10}|") 
# 输出: |====Hi====|

# 3. 左对齐，宽度10，使用 '*' 填充
print(f"|{text:*<10}|") 
# 输出: |Hi********|
```

### 常用方法

- `find()` 返回首次出现的位置(下标)
- `rfind()` 返回最后出现的位置(下标)
- `index`:返回首次出现的位置(下标)
- `rindex`:返回最后一次出现的位置(下标)
> 当子串不存在的时候:
> - `find()` / `rfind()` 会返回 `-1`（表示没找到）；
> - `index()` / `rindex()` 会直接**报错**（抛出 `ValueError`）

- 字符串拼接 `.john()`
`指定分隔符.join(字符串变量/可迭代对象)`
- **指定分隔符**：是一个字符串（比如`","`、`"-"`、空字符串`""`），会插入到每个元素之间；
- **字符串变量 / 可迭代对象**：一般是列表或元组

e.g.
```Python
# 用逗号作为分隔符，连接列表里的元素
li = ["a", "b", "c"]
result = ",".join(li)
print(result)  # 输出："a,b,c"

# 用空字符串作为分隔符（直接拼接）
result2 = "".join(li)
print(result2)  # 输出："abc"

# 用短横线作为分隔符
result3 = "-".join(li)
print(result3)  # 输出："a-b-c"
```

## 正则表达式

### 基本语法


| **语法**  | **含义**        |
| ------- | ------------- |
| a       | 普通字符，原样匹配     |
| .       | 任意单个字符        |
| \d      | 数字            |
| \w      | 字母 / 数字 / 下划线 |
| \s      | 空白字符          |
| `[abc]` | a 或 b 或 c     |
| `[a-z]` | 小写字母          |
| `[^a]`  | 非 a           |

数量限定符:

| **语法** | **含义**   |              |
| ------ | -------- | ------------ |
| *      | 0 次或多次   |              |
| +      | 1 次或多次   |              |
| ?      | 0 次或 1 次 | 放在前面,表示可有可不有 |
| {n}    | n 次      |              |
| {n,}   | ≥ n 次    |              |

常用位置符号:

| **语法** | **含义** |
| ------ | ------ |
| ^      | 行首     |
| $      | 行尾     |
| \b     | 单词边界   |

### 相关查找方法

- `search(pattern,string)`: string 中 pattern 匹配的**第一个位置**(全局找)
  返回:第一个位置匹配的对象
- `match(pattern,string)` : 从**第一个字符开始匹配**,只有开头部分符合返回匹配结果(只看从开头匹配的)

```Python
import re
s = "abc123"
pattern="\d+"
print(re.match(pattern, s))	#None
print(re.search(pattern, s))	#123
```

- `fullmatch(pattern,string)`:**整个字符串**和模式完全一致（无多余）
- `sub(pattern,repl,string)`:用  `repl`  替换掉匹配的字符串


| `match()`    | 只看开头对不对，后面不管     |
| ------------ | ---------------- |
| `search()`   | 扫一遍全文，找到第一个对的就行  |
| `fullmatc()` | 从头到尾都得对，多一个字符都不行 |

## 文件操作

处理文件通用步骤:
1. 打开文件
2. 操作文件(读/写)
3. 关闭文件

### 打开文件

使用内置函数 `open`
语法: `file_obj = open(file_path, mode, encoding=None)`

模式:
第一个字母:
1. `r` 读
2. `w`:写
3. `a`:末尾追加
4. `x`:创建新文件进入写模式
5. `+`

第二个字母:
1. `t`:文本模式(默认)
2. `b`:二进制模式,用于处理非文本文件
> 当文件打开是二进制模式,若要对文件写入字符串 `s`,要先对其编码 `s.encode('utf-8')`
> 而默认打开文本模式,则无需编码.

### 读取文件
- `read()`:返回整个文件的字符串,若传入参数如 `10` 就会读取前 10 个字符\
- `readlines`:每一行作为列表的一个元素

### 写入文件
- `write()` 写入文本
- `writelines(lineslist)`:写入列表 `lineslist` 所有字符串

### 上下文管理语法
`with` 是上下文管理语法,核心作用是**自动管理资源的创建和释放**,即自动关闭文件

e.g.
```Python
with open("test.txt", "r") as f:
	content=f.read()
```

### CSV 文件
CSV 本质是一种纯文本文件,用 `,` 作为数据的分隔符

核心特点
- 值无类型,所有值都是字符串
- 每行列数相同,第一行是标题(列名)
- **数据项没有固定宽度**,用于大数据存储处理

example:
```
姓名,年龄,班级
张三,18,高一1班
李四,17,高一2班
```

#### 文件读取

- `csv.reader()` 获取 csv 文件的每行数据(<mark style="background: #D2B3FFA6;">每行是一个列表</mark>)

实例:
```Python
import csv
# 打开CSV文件
with open("data.csv", "r", encoding="utf-8") as f:
    reader = csv.reader(f)  # 创建读取器
    for row in reader:      # 遍历读取每行
        print(row)  # 输出：['姓名', '年龄', '班级']、['张三', '18', '高一1班']等
```

- `csv.DictReader()` 作用与 `csv.reader()` 类似,但是每行数据被<mark style="background: #D2B3FFA6;">包装成字典</mark>(每一行都是一个字典,键是 CSV 的标题行,值是对应列的内容)

#### 文件写入

-  `csv.writer()` + `writerow()`
`csv.writer()` 创建一个 “CSV 写入器”，`writerow()` 用于**写入一行数据**（参数是**列表**，对应一行的各列值）

实例:
```Python
with open("output.csv", "w", encoding="utf-8", newline="") as f:
    writer = csv.writer(f)          # 创建写入器
    writer.writerow(["姓名", "年龄"])  # 写入标题行
    writer.writerow(["张三", "18"])   # 写入数据行
```


- `csv.DictWriter()`

```Python
dict_writer.writerow({"姓名": "李四", "年龄": "17"})
```


## 异常处理

异常处理常用语法:

### `try-except` 语句

捕获指定类型的异常,并处理
语法:
```Python
try:
    <检测语句>  # 可能出错的代码（比如读取文件、计算）
except <错误类型> as e:
    <处理异常>  # 出错时执行的代码（比如打印提示）
```

先执行 `try` 里的代码,若出错且错误类型匹配 `except`，执行 `except` 里的处理代码.

### 多个 `except`

对多个不同类型的异常处理
语法:
```Python
try:
    <检测语句>
except <错误类型1> as e1:
    <处理e1的代码>
except <错误类型2> as e2:
    <处理e2的代码>
```
> 后面也可以接 `finally`,一定会执行语句

### 必须执行处理 `try-finally` 语句

无论 `try` 是否引发异常, `finally` 里的代码一定会执行
语法:
```Python
try:
    <检测语句>
except <错误类型> as e:
    <处理异常>
finally:	#一定会执行
    <必执行的代码>  # 比如关闭文件、释放资源
```

### 无异常执行：`try-except-else` 语句

`else` 里的代码，只有当 `try` 里的代码**完全没出错**时才执行；
语法:
```Python
try:
    <检测语句>
except <错误类型> as e:
    <处理异常>
else:
    <没出错时执行的代码>
```

区分:

| `try-except-else`     | `try-finally`           |
| --------------------- | ----------------------- |
| 只有在异常的时候才执行 `else` 代码 | 无论有无异常,都执行 `finally` 代码 |
|                       |                         |
## HTML

HTML 的最外层框架是:
```
<html>
  <body>
    <!-- 网页的内容（文字、图片、表格等）都写在这里 -->
  </body>
</html>
```

### 常见的 HTML 标签

#### h 标签:标题标签

作用:定义不同层级的标题
写法:
```html
<h1>标题1（最大）</h1>
<h2>标题2</h2>
...
<h6>标题6（最小）</h6>
```

#### p 标签:段落标签
作用:定义一个段落
`<p>这是一段文字，会自动作为一个段落显示。</p>`

#### a 标签:超链接标签
作用:定义一个可以点击的链接,跳转到其他网页/地址

#### table/tr/td 标签:表格标签
作用:定义表格（`table` 是整个表格，`tr` 是一**行**，`td` 是单元格）
写法:
```html
<table>
  <tr> <!-- 第一行 -->
    <td>单元格1内容</td>
    <td>单元格2内容</td>
  </tr>
  <tr> <!-- 第二行 -->
    <td>单元格3内容</td>
    <td>单元格4内容</td>
  </tr>
</table>
```

#### div 标签:块容器标签
作用:建造一个块,分块处理,中间可以是上述的所有东西
写法:
```html
<div>
	...
</div>
```

## urllib 库

urllib 库是 Python 的自带库,用于网络爬取数据

### 重要方法
- `urllib.request` : 发送请求,返回结果是 `response` 对象
- `urllib.response`:网页应答
- `urllib.parse`:处理 URL 的编码解码,拼接
- `urllib.robotparser`:判断目标网站是否允许爬虫
- `urllib.error`:定义请求过程中可能出现的错误

### get 方式传递参数

get 请求的参数是直接拼接在 URL 后面的. 
语法:
```Python
urllib.request.Request(网页URL, headers=浏览器参数)
```
对参数与网页绑定传送

例如:
```Python
params = {"wd": "Python"}	#定义参数
# 2. 把参数编码后拼接到URL
url = f"https://www.baidu.com/s?{urllib.parse.urlencode(params)}"
```

### POST 方式传递参数

POST 请求的参数是放在请求体里的,不显示在 URL 中
语法:
```Python
urllib.request.Request(网页URL, data=编码后的参数, headers=浏览器参数, method="POST")
```
- `data`:参数先转成**字节类型**(`urllib.parse.urlencode().encode("utf-8")`)

### 两者区别

|            | get 方式               | POST 方式                        |
| ---------- | -------------------- | ------------------------------ |
| 参数位置       | 拼接在 URL 后面           | 放在请求体内                         |
| Request 参数 | 只用 `url` 和 `headers` | 还需要传入 `data` 和 `method="POST"` |


## requests 库(选看)
比 urllib 更简洁，自动处理连接复用和 URL 编码，是目前 Python 最主流的 HTTP 库。

### 主要的请求方法

| **方法**   | **语法示例**                 | **考点备注**     |
| -------- | ------------------------ | ------------ |
| **GET**  | `r = requests.get(url)`  | 参数用 `params` |
| **POST** | `r = requests.post(url)` | 参数用 `data`   |

### 常见方法

|**属性/方法**|**说明**|**关键点 (记忆技巧)**|
|---|---|---|
|**`r.status_code`**|HTTP状态码|`200` 表示成功，`404` 失败。常用于 `if r.status_code == 200:`|
|**`r.text`**|响应内容的**字符串**|用于**文本/HTML**。自动根据 `r.encoding` 解码。|
|**`r.content`**|响应内容的**二进制**|用于**图片/视频/音频**。保存文件时必须用 `wb` 模式。|
|**`r.encoding`**|猜测的编码方式|可以手动赋值修正乱码：`r.encoding = 'utf-8'`|
|`r.apparent_encoding`|备选编码方式|更加准确的编码猜测（分析内容得出），比 encoding 慢。|
|`r.json()`|JSON解码器|如果网页返回的是 JSON 格式，直接转换成 Python 字典。|

## Beautiful Soup

Beautiful Soup 核心作用是解析爬取到的 HTML 网页源码,提取需要的数据(提取纯文本,表格图片等内容)

### 初始化语句

```Python
Soup = BeautifulSoup(html, 'html.parser')
```
- `html`:爬取的网页源码字符串
- `html.parser`:指定解析器
- `soup`:执行后返回结构化的 HTML 对象,可以通过 `soup` 提取数据

### 提取标签/属性

#### 获取标签的内容和指定属性

- `Soup.title`:获取网页的 `<title>` 标签对象
	- `Soup.title.name`:获取 `<title>` 标签的标签名 `
	- `Soup.title.text`:获取 `<title>` 标签内的纯文本内容
	- `Soup.title.content`:获取 `<title>` 标签的内容 
- `Soup.a.attrs`: 获取标签中第一个 `<a>` 标签的所有属性
- `Soup.a.["class"]`: 获取第一个 `<a>` 标签的 class 属性值
- `Soup.find_all('a')`:查找页面中所有 `<a>` 标签,返回的是标签对象的链表

### 爬虫流程

- 分析网页,找到要爬取的内容的标签/id
- 爬取页面,保存为文本文件(用 `urllib` / `requests` 获取网页源码)
- 解析页面
   - HTML 代码:网页解析器,如 `Beautiful Soup`
   - JSON 数据:用 Python 自带的 `json` 模块
   - 二进制数据:用 `wb` 模式写入文件
   -  程序结构设计:
      - 获取网页内容 `html = askURL(url)` (askURL 为封装的请求函数)
      -  提取整理数据 `data_list=getData(html)`
      - 保存数据

### Scrapy

### 核心命令流程
- `scrapy startproject <name1>`:生成一个 name 1 的文件夹,包含 Scrapy 项目的基础文件/目录
- `scrapy genspider [option] <name2>` 生成一个具体的爬虫文件, `option` 是爬取的域名
- 编写代码
- `scrapy crawl name2`: 运行爬虫 


## 🐼 Pandas

Pandas 是 Python 的数据分析库，提供 3 种结构化数据容器

### Series 向量

包含索引和值
示例：`x = [1,4,5,7]` → 用`pd.Series([1,4,5,7])`创建

### 二维数组：DataFrame

带行索引 + 列名的表格型结构”(类似 Excel 表格)
类似表格的结构:

|     | A   | B   | C   |
| --- | --- | --- | --- |
| 0   |     |     |     |
| 1   |     |     |     |
| 2   |     |     |     |
| 3   |     |     |     |

### 基础操作

#### 查看基础信息

- `df.index`：查看 DataFrame 的**行索引**；
- `df.columns`：查看 DataFrame 的**列名**；
- `df.values`：查看 DataFrame 的**所有值**（返回二维数组）

#### 查看统计信息

- `df.describe()`：自动计算数值列的统计指标（平均值、方差、最大值、最小值等）

### 缺失值处理
- `df.dropna()`：删除包含 ** 缺失值（空值）** 的行，得到无缺失值的数据集。

### 数据处理

`df.groupby("分组列")["目标列"].操作()`:根据分组对目标进行处理把符合的统计成一个组,操作常见为 count 统计,统计组内的数量.返回一个 `DataFrame`,行是分组,列是操作的结果

## matplotlib 绘图

matplotlib 是 Python 的绘图扩展库常用模块是 `pylab` 和 `pylot` (常用,简写成 `plt`)

### 重要图形对应的函数

| 折线图 | `plot()`    |
| --- | ----------- |
| 散点图 | `scatter()` |
| 柱状图 | `bar()`     |
| 饼图  | pie()       |

### 一个函数图的绘制步骤
以函数 `s=sint(t)` 为例
1. 定义自变量范围: `plt.arange(起点,终点,步长)`
2. 设置函数: `s=np.sint(t)`
3. 绘制图形:传入自变量加因变量
   `plt.plot(t, s, label="sin(t)", color="blue") # t是x轴，s是y轴`
4. 设置坐标轴标题: `plt.xlabel("时间 t") plt.ylabel("函数值 s=sin(t)")`
5. 设置图的标题: `plt.title("xxx")
6. 图中文字/样式设置
7. 显示图形: `plt.show()`

## GUI 编程(上课没讲但考题有)

常见的事件绑定:
- **`<Button-1>`**：鼠标**左键**单击 (1代表左)
- **`<Button-2>`**：鼠标中键单击
- **`<Button-3>`**：鼠标**右键**单击 (3代表右)
- **`<Double-Button-1>`**：鼠标左键双击

---
## 查漏补缺

- **Find vs Index**的区别[[#常用方法]]
- 正则表达式函数的区别: [[#相关查找方法]]
- Scrapy 的创建命令: [[#核心命令流程]]
- 散点图柱状图的函数名称: [[#重要图形对应的函数]],记住饼图是 `pie()`